/*	  Copyright (C) 2000,2001,2002  Sony Computer Entertainment America

       	  This file is subject to the terms and conditions of the GNU Lesser
	  General Public License Version 2.1. See the file "COPYING" in the
	  main directory of this archive for more details.                             */

#ifndef renderer_h
#define renderer_h

#include "ps2s/packet.h"

#include "GL/gl.h"

/********************************************
 * flags describing what pieces of microcode can do/
 * need to do
 */

class CRendererProps {
public:
    uint64_t PrimType : 3;
    uint64_t Lighting : 1;
    uint64_t NumDirLights : 2;
    uint64_t NumPtLights : 3;
    uint64_t Texture : 1;
    uint64_t Specular : 1;
    uint64_t PerVtxMaterial : 3;
    uint64_t Clipping : 2;
    uint64_t CullFace : 1;
    uint64_t TwoSidedLighting : 1;
    uint64_t ArrayAccess : 2;

    uint64_t unused : 12;

    uint64_t UserProps : 32;

    // convert to unsigned 64-bit value

    inline operator uint64_t() const
    {
        // this hack doesn't work on linux since the compiler thinks this is a 32-bit
        // machine..
        // asm (" ### CRendererProps to uint ### " : "=r" (value) : "0" (*this) );

        uint64_t* value = (uint64_t*)this;
        return *value;
    }

    inline void operator=(uint64_t value)
    {
        // see above..
        // asm(" ### CRendererProps assign from u64 ### " : "=r" (*(uint64_t*)this) : "0" (value) );

        *this = *(CRendererProps*)&value;
    }
} __attribute__((aligned(8)));

namespace RendererProps {
typedef enum { kPtsLinesStripsFans = 1 << 0,
    kTriangles                     = 1 << 1,
    kQuads                         = 1 << 2 } tPrimType;

typedef enum { k3DirLights = 1 << 0,
    k8DirLights            = 1 << 1 } tNumDirLights;

typedef enum { k1PtLight = 1 << 0,
    k2PtLights           = 1 << 1,
    k8PtLights           = 1 << 2 } tNumPtLights;

typedef enum { kNoMaterial = 1 << 0,
    kDiffuse               = 1 << 1,
    kSpecular              = 1 << 2 } tPerVtxMaterial;

typedef enum { kLinear = 1 << 0,
    kIndexed           = 1 << 1 } tArrayAccess;

typedef enum { kNonClipped = 1 << 0,
    kClipped               = 1 << 1 } tClipping;
}

class CGeometryBlock;
class CVertArray;

/**
 * This class defines the interface for renderers.  Note
 * that it contains pure virtual methods and so
 * cannot be instantiated.
 */
class CRenderer {
protected:
    uint64_t Capabilities;
    uint64_t Requirements;

    // this class can't be instantiated
    CRenderer() {}
    CRenderer(uint64_t caps, uint64_t reqs)
        : Capabilities(caps)
        , Requirements(reqs)
    {
    }

    void SetCapabilities(uint64_t caps) { Capabilities = caps; }
    void SetRequirements(uint64_t reqs) { Requirements = reqs; }

public:
    virtual uint64_t GetCapabilities() const { return Capabilities; }
    virtual uint64_t GetRequirements() const { return Requirements; }

    /// called by the geometry manager when the default renderer context has changed,
    /// when the user context has changed, or after the renderer has been loaded
    /// (and a different renderer was in use).  The renderer must record all necessary
    /// context at this point (usually by adding it to the vif1 chain) as the
    /// rendering context may have changed when it is called to actually render with
    /// Draw*Arrays().
    /// @param primType the primitive type to render (can be a custom type)
    /// @param rcChanges changed in the rendering context as returned by
    /// CGLContext::GetRendererContextChanged().
    /// @param userRcChanged whether the user (custom) rendering context has changed
    virtual void InitContext(GLenum primType, uint32_t rcChanges, bool userRcChanged) = 0;

    /// Load the renderer into vu0/vu1 memory.
    virtual void Load() = 0;

    /// Draw arrays of vertices that are accessed linearly (i.e., glDrawArrays)
    virtual void DrawLinearArrays(CGeometryBlock& block)
    {
        mError("This renderer doesn't do linear arrays");
    }
    /// Draw arrays of vertices that are accessed by index (i.e., glDrawElements)
    virtual void DrawIndexedArrays(CGeometryBlock& block)
    {
        mError("This renderer doesn't do indexed arrays");
    }

    /// Can the packets generated by this renderer for the given geometry be cached
    /// when called from a display list, or should they be rebuilt each time?
    /// (The default renderers, for example, don't cache packets that depend on the
    /// current normal when lighting is enabled.)
    virtual bool GetCachePackets(const CGeometryBlock& geometry) = 0;

    /// What parts of the render context are encoded into packets produced by
    /// this renderer?  When the packets are cached in display lists, this
    /// cached state must remain valid to continue using the cached packet.
    /// This method returns a CRendererProps bitmask with '1' set for each
    /// property that is cached in the packet.  Note that this does <b>not</b>
    /// include the render context kept by InitContext(); this will never be
    /// cached by ps2gl.
    /// The default renderers, for example, do not transfer normals even when
    /// specified if lighting is not enabled.  The packets they generate
    /// therefore depend on whether or not lighting is enabled, so they set the
    /// "Lighting" bit.
    virtual CRendererProps GetRenderContextDeps() = 0;

    /// Estimate the amount of memory, in qwords, the packet to render "geometry"
    /// will take.  (For display list cacheing.)
    virtual int GetPacketQwordSize(const CGeometryBlock& geometry) = 0;

    /// Return a pointer to the text name of this renderer
    virtual const char* GetName() = 0;
};

#endif // renderer_h
